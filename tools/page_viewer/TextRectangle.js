// Generated by CoffeeScript 1.6.2
(function() {
  var Rectangle, RectangleGroup;

  Rectangle = function(x, y, w, h, args) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    return this.args = args;
  };

  Rectangle.prototype = {
    constructor: Rectangle,
    clone: function() {
      return new Rectangle(this.x, this.y, this.w, this.h, this.args);
    },
    area: function() {
      return this.w * this.h;
    },
    vertices: function() {
      return [[this.x, this.y], [this.x + this.w, this.y], [this.x + this.w, this.y + this.h], [this.x, this.y + this.h]];
    },
    distance: function(other) {
      var d, dx, dy, i, j, minDist, v1, v2, vertices, _i, _j, _len, _len1, _ref;

      if (this.intersect(other)) {
        return 0;
      }
      minDist = Infinity;
      vertices = other.vertices();
      _ref = this.vertices();
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v1 = _ref[i];
        for (j = _j = 0, _len1 = vertices.length; _j < _len1; j = ++_j) {
          v2 = vertices[j];
          dx = v1[0] - v2[0];
          dy = v1[1] - v2[1];
          d = dx * dx + dy * dy;
          if (d < minDist) {
            minDist = d;
          }
        }
      }
      return minDist;
    },
    union: function(other) {
      var maxX, maxY, minX, minY;

      minX = Math.min(this.x, other.x);
      minY = Math.min(this.y, other.y);
      maxX = Math.max(this.x + this.w, other.x + other.w);
      maxY = Math.max(this.y + this.h, other.y + other.h);
      return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    },
    intersect: function(other) {
      var intersectX, intersectY, lineIntersect;

      lineIntersect = function(line1, line2) {
        var left, right, _ref, _ref1;

        left = line1;
        right = line2;
        if (right[0] < left[0]) {
          _ref = [right, left], left = _ref[0], right = _ref[1];
        }
        if (!((left[0] <= (_ref1 = right[0]) && _ref1 < left[1]))) {
          return null;
        }
        if (right[1] >= left[1]) {
          return [right[0], left[1]];
        }
        return right;
      };
      intersectX = lineIntersect([this.x, this.x + this.w], [other.x, other.x + other.w]);
      if (!intersectX) {
        return null;
      }
      intersectY = lineIntersect([this.y, this.y + this.h], [other.y, other.y + other.h]);
      if (!intersectY) {
        return null;
      }
      return new Rectangle(intersectX[0], intersectY[0], intersectX[1] - intersectX[0], intersectY[1] - intersectY[0]);
    }
  };

  RectangleGroup = function() {
    var i, r, _i, _len, _ref;

    this.elements = _.filter(arguments, function(arg) {
      return arg instanceof Rectangle;
    });
    this.minBoundingRectangle = null;
    if (this.elements.length === 0) {
      return;
    } else {
      this.minBoundingRectangle = this.elements[0];
      _ref = this.elements;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        r = _ref[i];
        if (i > 0) {
          this.minBoundingRectangle = this.minBoundingRectangle.union(this.elements[i]);
        }
      }
    }
  };

  RectangleGroup.prototype = {
    constructor: RectangleGroup,
    distance: function(other) {
      return this.minBoundingRectangle.distance(other.minBoundingRectangle);
    },
    union: function(other) {
      var r, ret, _i, _len, _ref;

      ret = new RectangleGroup();
      ret.elements = (function() {
        var _i, _len, _ref, _results;

        _ref = this.elements;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          _results.push(r.clone());
        }
        return _results;
      }).call(this);
      ret.minBoundingRectangle = this.minBoundingRectangle.clone();
      _ref = other.elements;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        ret.elements.push(r);
        ret.minBoundingRectangle = ret.minBoundingRectangle.union(r);
      }
      return ret;
    }
  };

  window.Rectangle = Rectangle;

  window.RectangleGroup = RectangleGroup;

}).call(this);
